<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Procedural Creature Simulation</title>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: black; }
    canvas { position: absolute; left: 0; top: 0; display: block; }
  </style>
</head>
<body>
<script>
  // === Input tracking ===
  const Input = { keys: Array(230).fill(false), mouse: { left: false, middle: false, right: false, x: 0, y: 0 } };
  document.addEventListener("keydown", e => Input.keys[e.keyCode] = true);
  document.addEventListener("keyup", e => Input.keys[e.keyCode] = false);
  document.addEventListener("mousedown", e => {
    if (e.button === 0) Input.mouse.left = true;
    if (e.button === 1) Input.mouse.middle = true;
    if (e.button === 2) Input.mouse.right = true;
  });
  document.addEventListener("mouseup", e => {
    if (e.button === 0) Input.mouse.left = false;
    if (e.button === 1) Input.mouse.middle = false;
    if (e.button === 2) Input.mouse.right = false;
  });
  document.addEventListener("mousemove", e => { Input.mouse.x = e.clientX; Input.mouse.y = e.clientY; });

  // === Canvas setup ===
  const canvas = document.createElement("canvas");
  document.body.appendChild(canvas);
  const ctx = canvas.getContext("2d");
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();
  ctx.strokeStyle = "white";

  // === Core classes ===
  let segmentCount = 0;
  class Segment {
    constructor(parent, size, angle, range, stiffness) {
      segmentCount++;
      this.parent = parent;
      parent.children = parent.children || [];
      parent.children.push(this);
      this.children = [];
      this.size = size;
      this.defAngle = angle;
      this.relAngle = angle;
      this.range = range;
      this.stiffness = stiffness;
      this.absAngle = parent.absAngle + angle;
      this.x = parent.x + Math.cos(this.absAngle) * this.size;
      this.y = parent.y + Math.sin(this.absAngle) * this.size;
    }
    updateRelative(iter = false, flex = true) {
      this.relAngle = this.relAngle - 2*Math.PI*Math.floor((this.relAngle - this.defAngle)/(2*Math.PI) + 0.5);
      if (flex) {
        const min = this.defAngle - this.range/2, max = this.defAngle + this.range/2;
        this.relAngle = Math.min(max, Math.max(min, (this.relAngle - this.defAngle)/this.stiffness + this.defAngle));
      }
      this.absAngle = this.parent.absAngle + this.relAngle;
      this.x = this.parent.x + Math.cos(this.absAngle)*this.size;
      this.y = this.parent.y + Math.sin(this.absAngle)*this.size;
      if (iter) for (const c of this.children) c.updateRelative(true, flex);
    }
    draw(iter = true) {
      ctx.beginPath();
      ctx.moveTo(this.parent.x, this.parent.y);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
      if (iter) for (const c of this.children) c.draw(true);
    }
    follow(iter = true) {
      const x0 = this.parent.x, y0 = this.parent.y;
      const dx = this.x - x0, dy = this.y - y0;
      const dist = Math.hypot(dx, dy) || 0.0001;
      this.x = x0 + this.size * dx/dist;
      this.y = y0 + this.size * dy/dist;
      this.absAngle = Math.atan2(this.y - y0, this.x - x0);
      this.relAngle = this.absAngle - this.parent.absAngle;
      this.updateRelative(false, true);
      if (iter) for (const c of this.children) c.follow(true);
    }
  }

  class LimbSystem {
    constructor(end, length, speed, creature) {
      this.end = end;
      this.creature = creature;
      this.speed = speed;
      creature.systems.push(this);
      this.nodes = [];
      let node = end;
      for (let i = 0; i < length; i++) {
        this.nodes.unshift(node);
        node = node.parent;
        if (!node || !node.isSegment) break;
      }
      this.hip = this.nodes[0].parent;
    }
    moveTo(x, y) {
      this.nodes[0].updateRelative(true, true);
      let len = Math.max(0, Math.hypot(this.end.x - x, this.end.y - y) - this.speed);
      for (let i = this.nodes.length - 1; i >= 0; i--) {
        const node = this.nodes[i];
        const ang = Math.atan2(node.y - y, node.x - x);
        node.x = x + len * Math.cos(ang);
        node.y = y + len * Math.sin(ang);
        x = node.x; y = node.y; len = node.size;
      }
      for (const node of this.nodes) {
        node.absAngle = Math.atan2(node.y - node.parent.y, node.x - node.parent.x);
        node.relAngle = node.absAngle - node.parent.absAngle;
        for (const c of node.children) if (!this.nodes.includes(c)) c.updateRelative(true, false);
      }
    }
    update() { this.moveTo(Input.mouse.x, Input.mouse.y); }
  }

  class LegSystem extends LimbSystem {
    constructor(end, length, speed, creature) {
      super(end, length, speed, creature);
      this.goalX = end.x; this.goalY = end.y;
      this.step = 0; this.forwardness = 0;
      this.reach = 0.9 * Math.hypot(this.end.x - this.hip.x, this.end.y - this.hip.y);
      const relAng = creature.absAngle - Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x);
      this.swing = -relAng + (2 * (relAng < 0) -1)*Math.PI/2;
      this.swingOffset = creature.absAngle - this.hip.absAngle;
    }
    update() {
      this.moveTo(this.goalX, this.goalY);
      if (this.step === 0) {
        const d = Math.hypot(this.end.x - this.goalX, this.end.y - this.goalY);
        if (d > 1) {
          this.step = 1;
          this.goalX = this.hip.x + this.reach * Math.cos(this.swing + this.hip.absAngle + this.swingOffset) + (Math.random()*2-1)*this.reach/2;
          this.goalY = this.hip.y + this.reach * Math.sin(this.swing + this.hip.absAngle + this.swingOffset) + (Math.random()*2-1)*this.reach/2;
        }
      } else if (this.step === 1) {
        const theta = Math.atan2(this.end.y - this.hip.y, this.end.x - this.hip.x) - this.hip.absAngle;
        const dist = Math.hypot(this.end.x - this.hip.x, this.end.y - this.hip.y);
        const forwardness2 = dist * Math.cos(theta);
        const dF = this.forwardness - forwardness2;
        this.forwardness = forwardness2;
        if (dF*dF < 1) {
          this.step = 0;
          this.goalX = this.hip.x + (this.end.x - this.hip.x);
          this.goalY = this.hip.y + (this.end.y - this.hip.y);
        }
      }
    }
  }

  class Creature {
    constructor(x, y, angle, fAccel, fFric, fRes, fThresh, rAccel, rFric, rRes, rThresh) {
      this.x = x; this.y = y; this.absAngle = angle;
      this.fAccel = fAccel; this.fFric = fFric; this.fRes = fRes; this.fThresh = fThresh;
      this.rAccel = rAccel; this.rFric = rFric; this.rRes = rRes; this.rThresh = rThresh;
      this.children = []; this.systems = [];
      this.fSpeed = 0; this.rSpeed = 0;
      this.isSegment = false;
    }
    follow(mx, my) {
      const dx = this.x - mx, dy = this.y - my, dist = Math.hypot(dx, dy);
      const angle = Math.atan2(my - this.y, mx - this.x);
      let accel = this.fAccel;
      if (this.systems.length) {
        const sum = this.systems.filter(s => s.step === 0).length;
        accel *= sum / this.systems.length;
      }
      this.fSpeed += accel * (dist > this.fThresh);
      this.fSpeed *= 1 - this.fRes;
      this.speed = Math.max(0, this.fSpeed - this.fFric);
      let dif = this.absAngle - angle;
      dif -= 2*Math.PI*Math.floor(dif/(2*Math.PI) + 0.5);
      if (Math.abs(dif) > this.rThresh && dist > this.fThresh) this.rSpeed -= this.rAccel * (2*(dif>0)-1);
      this.rSpeed *= 1 - this.rRes;
      if (Math.abs(this.rSpeed) > this.rFric) this.rSpeed -= this.rFric*(2*(this.rSpeed>0)-1);
      else this.rSpeed = 0;
      this.absAngle += this.rSpeed;
      this.absAngle -= 2*Math.PI*Math.floor(this.absAngle/(2*Math.PI)+0.5);
      this.x += this.speed*Math.cos(this.absAngle);
      this.y += this.speed*Math.sin(this.absAngle);
      this.absAngle += Math.PI;
      for (const c of this.children) c.follow(true, true);
      for (const sys of this.systems) sys.update(mx, my);
      this.absAngle -= Math.PI;
      this.draw(true);
    }
    draw(iter = true) {
      const r = 4;
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, Math.PI/4+this.absAngle, 7*Math.PI/4+this.absAngle);
      ctx.moveTo(this.x + r*Math.cos(7*Math.PI/4+this.absAngle), this.y + r*Math.sin(7*Math.PI/4+this.absAngle));
      ctx.lineTo(this.x + r*Math.cos(this.absAngle)*Math.SQRT2, this.y + r*Math.sin(this.absAngle)*Math.SQRT2);
      ctx.lineTo(this.x + r*Math.cos(Math.PI/4+this.absAngle), this.y + r*Math.sin(Math.PI/4+this.absAngle));
      ctx.stroke();
      if (iter) for (const c of this.children) c.draw(true);
    }
  }

  // === Setup: lizard with random legs and tail ===
  function setupLizard(size, legs, tail) {
    const critter = new Creature(canvas.width/2, canvas.height/2, 0,
      size*10, size*2, 0.5, 16, 0.5, 0.085, 0.5, 0.3);
    let spinal = critter;
    // neck
    for (let i = 0; i < 6; i++) {
      spinal = new Segment(spinal, size*4, 0, 2*Math.PI*2/3, 1.1);
      for (const ii of [-1, 1]) {
        let node = new Segment(spinal, size*3, ii, 0.1, 2);
        for (let iii = 0; iii < 3; iii++) node = new Segment(node, size*0.1, -ii*0.1, 0.1, 2);
      }
    }
    // torso with legs
    for (let i = 0; i < legs; i++) {
      if (i>0) {
        for (let ii = 0; ii < 6; ii++) {
          spinal = new Segment(spinal, size*4, 0, Math.PI/2, 1.5);
          for (const iii of [-1,1]) {
            let node = new Segment(spinal, size*3, iii*Math.PI/2, 0.1, 1.5);
            for (let iv = 0; iv < 3; iv++) node = new Segment(node, size*3, -iii*0.3, 0.1, 2);
          }
        }
      }
      for (const ii of [-1,1]) {
        let node = new Segment(spinal, size*12, ii*0.785, 0, 8);
        node = new Segment(node, size*16, -ii*0.785, 6.28, 1);
        node = new Segment(node, size*16, ii*1.571, Math.PI, 2);
        for (let iii = 0; iii < 4; iii++) {
          new Segment(node, size*4, (iii/3 - 0.5)*1.571, 0.1, 4);
        }
        new LegSystem(node, 3, size*12, critter);
      }
    }
    // tail
    spinal = spinal;
    for (let i = 0; i < tail; i++) {
      spinal = new Segment(spinal, size*4, 0, 2*Math.PI*2/3, 1.1);
      for (const ii of [-1,1]) {
        let node = new Segment(spinal, size*3, ii, 0.1, 2);
        for (let iii = 0; iii < 3; iii++) {
          node = new Segment(node, size*3*(tail-i)/tail, -ii*0.1, 0.1, 2);
        }
      }
    }
    return critter;
  }

  const legNum = Math.floor(1 + Math.random()*12);
  const critter = setupLizard(8 / Math.sqrt(legNum), legNum, Math.floor(4 + Math.random()*legNum*8));

  // === Animation loop ===
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    critter.follow(Input.mouse.x, Input.mouse.y);
    requestAnimationFrame(animate);
  }
  animate();
</script>
</body>
</html>
